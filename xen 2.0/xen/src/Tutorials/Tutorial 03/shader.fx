
//This shader is compiled using a visual studio CustomTool plugin, which is installed when running 
//the build file in the root directory of the Xen zip

//When viewing the properties for this file, the 'Custom Tool' value should be 'XenFX'.
//When creating your own shaders, simply add them to the project and set the 'Custom Tool' property.

//The plugin compiles shaders, and generates a C# class that is used at runtime.

//The shader compiler will generate a class for each Technique in this .fx file. 
//These classes will all implement the IShader interface.
//The code is generated whenever the file is saved.
//Shader compile errors will appear in the Error List, just like regular code compile errors.

//For example,
//uncomment the next line, then save the file with ctrl-S.

//float test = undefinedValue;

//The shader compile should fail, showing the following error in the visual studio Error List:
//Custom tool warning: (18): error X3004: undeclared identifier 'undefinedValue'
//This indicates the custom tool has failed on line 18.
//In this case, 'undefinedValue' is not a known value, the shader compiler can't find it.
//re-comment the line, save the file, and it should compile correctly.


//In the solution explorer (project file view), shader.fx should have a '+' or '>' box to the left.
//expand it, and it should show an attached file 'shader.fx.cs'.
//This is the code file generated by the XenFX plugin.

//Note this shader code file is part of the main project, it is NOT part of the Content project
//The shader byte-code is compressed and embedded into the generated class file, and will be
//part of the compiled .exe/.dll.
//A game does not need to worry about shader content being included in the project correctly.




//... on to the example shader


float4x4 worldViewProj : WORLDVIEWPROJECTION;


//Here, the world*view*projection matrix is declared.
//Unlike in Xna Effect files, the Semantic is very important.
//In this case, the semantic is 'WORLDVIEWPROJECTION'.

//The class that is generated will automatically set this value to the world*view*projection matrix.
//The generated class does not let you set this constant manually.

//There is a large list of semantics available for shader constants.
//Any combination of WORLD, VIEW and PROJECTION can be used (although only in that order).
//These can also have 'TRANSPOSE' or 'INVERSE' on the end.
//So WORLDTRANSPOSE, VIEWPROJECTION and PROJECTIONINVERSE are all valid.
//VIEWWORLD or WORLDINVERSEVIEW, etc, are not valid - because they are in the wrong order.
//All matrix semantic-bound constants should be declared as 4x4 matrices (float4x4).

//There are also some non-matrix constants available. These must be declared as the type shown.

// float2 windowSize	: WINDOWSIZE;			// pixel size of the current draw target (screen or texture)
// float2 cameraFov		: CAMERAFOV;			// horizontal and vertical fov of the camera
// float2 cameraFovTan	: CAMERAFOVTANGENT;	
// float2 cameraNearFar	: CAMERANEARFAR;		// near / far clip planes of the camera
// float3 viewPoint		: VIEWPOINT;			// position of the camera
// float3 viewDirection	: VIEWDIRECTION;		// direction the camera is looking in

//viewPoint and viewDirection may also be declared as float4.




float4 colour : GLOBAL;

//In this case, a special semantic is used. GLOBAL can be applied to any type.
//The DrawState object keeps lists of every global shader constant.
//Global values are application-wide.
//It is intended that globals are set infrequently, or at most once per frame.
//Globals are not designed to be set every time an object is drawn.
//Set a global with the DrawState or FrameState object, call 'state.ShaderGlobals.SetShaderGlobal("name", value)'






//finally, a constant without a semantic:

float scale = 1;


//These constants are known as attributes. They are designed to be set frequently.

//If this value is used by the technique, a set-only property 'float Scale {set;}' will be created in
//the generated class.
//A method 'SetScale(ref)' will also be created for types more complex than float - and is the
//preferred method for setting complex values.




//---------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------

//That is the basics of the shader system covered.
//The rest of the code in this file implements the example shader logic.

//See the tutorial code file for examples of setting the global colour, binding the shader instance, and
//setting the attribute value.



//--------------------------------------------------------------//
// vertex shader, scales the mesh by the scale attribute
//--------------------------------------------------------------//
void Tutorial03VS(	
					float4 position			: POSITION, 
				out float4 positionOut		: POSITION)
{
	position.xyz *= scale;
	
	positionOut = mul(position,worldViewProj);
}


//--------------------------------------------------------------//
// pixel shader, returns the global colour
//--------------------------------------------------------------//
float4 Tutorial03PS() : COLOR 
{
	return colour;
}



//--------------------------------------------------------------//
// Technique that uses the shaders (a class will be generated)
//--------------------------------------------------------------//
technique Tutorial03Technique
{
   pass
   {
		VertexShader = compile vs_2_0 Tutorial03VS();
		PixelShader = compile ps_2_0 Tutorial03PS();
   }
}




//---------------------------------------------------------------------------------------------------
//Advanced use:
//---------------------------------------------------------------------------------------------------

//The following covers advanced uses of the shader system

//Sometimes an attribute must be set through an IShader interface - where the shader class type is unknown.
//For performance reasons, you cannot set an attribute by string name.
//All attribute names have a unique integer ID.
//The DrawState object can get a unique ID using 'GetShaderAttributeNameUniqueID("name")'.
//This ID will never change for the entire life of the application.
//The value returned will always be a positive integer that is greater than zero.
//A good time to call GetShaderAttributeNameUniqueID() would be in a ContentLoad, keeping a local copy
//of the index.
//Every shader instance will implement 'SetAttribute(...)' methods, which will return true if the
//attribute was set correctly.


//As demonstrated in the Tutorial code, the DrawState object has a generic method 'GetShader<T>'
//This method will get an application-wide global instance of a shader (by generic type)
//Calling this method is very fast.
//Shaders are quite CPU efficient, so reusing them is encouraged.
//Creating an instance per use will add memory overhead - the CPU overhead difference will be fairly small.


//The shader generated by this file will use around 128 bytes per instance.
//Most of this is the 64bytes for the WorldViewProjection matrix.
//It will use around 48 static bytes and around 140 bytes for the embedded static shader code.
//More complex shaders obviously use more memory.

//There are a few restrictions on what can be used in a shader compiled with the plugin,
//The largest restriction is that Techniques may not make changes to render state.
//The choice was intentional not to support render state changes. While at first it may seem
//useful, in larger projects having shaders changing render state can cause a *lot* of very
//subtle bugs that can be very difficult to fix.

//A shader is intended to only change shader state, not render state.
//By extension of this restriction, multi-pass shaders are not supported by the plugin.

//Although, there is one exception. Texture sampler states may be set by the shader.
//This is because texture sample state changes the shader output, whereas render state does not.
//(The default texture sampler mode is always bilinear filtering)

//Custom structures cannot be used for shader attributes.
//(This doesn't work properly with effects either)



//Finally, compiler hints can be provided to the custom tool.
//This can be done by setting the very first line of a shader .fx file to a special comment.
//For example, set the very first line of this file to:

//CompilerOptions = InternalClass

//And the generated shader class will be an internal class, not accessible outside the project.
//The following options are supported (in the following format):
//CompilerOptions = NoPreShader, InternalClass, ParentNamespace, AvoidFlowControl, PreferFlowControl, PartialPrecision, DefinePlatform

//If your shader requires XBOX specific logic, then use the 'DefinePlatform' compiler option.
//When used, the shader will be defined for each platform.
//(the shader will be generated once for windows and once for xbox).
//
//The macro 'XBOX360' will be defined, allowing:
//
//#ifdef XBOX360
//...
//#else
//...
//#endif
//
//

//---------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------